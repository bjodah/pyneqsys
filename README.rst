pyneqsys
========

.. image:: http://hera.physchem.kth.se:9090/api/badges/bjodah/pyneqsys/status.svg
   :target: http://hera.physchem.kth.se:9090/bjodah/pyneqsys
   :alt: Build status
.. image:: https://img.shields.io/pypi/v/pyneqsys.svg
   :target: https://pypi.python.org/pypi/pyneqsys
   :alt: PyPI version
.. image:: https://img.shields.io/pypi/l/pyneqsys.svg
   :target: https://github.com/bjodah/pyneqsys/blob/master/LICENSE
   :alt: License
.. image:: http://hera.physchem.kth.se/~pyneqsys/branches/master/htmlcov/coverage.svg
   :target: http://hera.physchem.kth.se/~pyneqsys/branches/master/htmlcov
   :alt: coverage

`pyneqsys <https://github.com/bjodah/pyneqsys>`_ provides a convenience class for 
representing and solving non-linear equation systems from symbolic expressions
(provided e.g. with the help of `SymPy <http://www.sympy.org>`_).

The numerical root finding is perfomed using either:

- scipy: `scipy.optimize.root <http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html>`_
- nleq2: `pynleq2.solve <http://bjodah.github.io/pynleq2/pynleq2.html#pynleq2.solve>`_ (unsettled API)
- kinsol: `pykinsol.solve <http://bjodah.github.io/pykinsol/pykinsol.html#pykinsol.solve>`_

Documentation
-------------
Autogenerated API documentation is found `here <http://hera.physchem.kth.se/~pyneqsys/branches/master/html>`_.

Installation
------------
Simplest way to install pyneqsys and its dependencies is through the `conda package manager <http://conda.pydata.org/docs/>`_:

::

   $ conda install -c bjodah pyneqsys pytest
   $ python -m pytest --pyargs pyneqsys


Source distribution is available here:
`<https://pypi.python.org/pypi/pyneqsys>`_

Example
-------
Example reformulated from `SciPy documentation <http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html>`_:

.. code:: python

   >>> from pyneqsys.symbolic import SymbolicSys
   >>> neqsys = SymbolicSys.from_callback(
   ...     lambda x: [(x[0] - x[1])**3/2 + x[0] - 1,
   ...                (x[1] - x[0])**3/2 + x[1]], 2)
   >>> x, info = neqsys.solve([1, 0])
   >>> assert info['success']
   >>> print(x)
   [ 0.8411639  0.1588361]

here we did not need to enter the jacobian manually, SymPy did that for us.
For expressions containing transcendental functions we need to provide a
"backend" keyword arguemnt to enable symbolic derivation of the jacobian:

.. code:: python

   >>> import math
   >>> def powell(x, params, backend=math):
   ...     A, exp = params[0], backend.exp
   ...     return A*x[0]*x[1] - 1, exp(-x[0]) + exp(-x[1]) - (1 + A**-1)
   >>> powell_sys = SymbolicSys.from_callback(powell, 2, 1)
   >>> x, info = powell_sys.solve([1, 1], [1000.0])
   >>> assert info['success']
   >>> print(', '.join(['%.6e' % _ for _ in sorted(x)]))
   1.477106e-04, 6.769996e+00

For more examples look see
`examples/ <https://github.com/bjodah/pyneqsys/tree/master/examples>`_, and rendered jupyter notebooks here:
`<http://hera.physchem.kth.se/~pyneqsys/branches/master/examples>`_


License
-------
The source code is Open Source and is released under the simplified 2-clause BSD license. See `LICENSE <LICENSE>`_ for further details.
Contributors are welcome to suggest improvements at https://github.com/bjodah/pyneqsys

Author
------
Bj√∂rn I. Dahlgren, contact:

- gmail address: bjodah
- kth.se address: bda
